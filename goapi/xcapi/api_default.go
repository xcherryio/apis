/*
xCherry APIs

This APIs between xCherry service and SDKs

API version: 0.0.3
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package xcapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)

type DefaultAPI interface {

	/*
		ApiV1XcherryServiceProcessExecutionDescribePost describe a process execution

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionDescribePostRequest
	*/
	ApiV1XcherryServiceProcessExecutionDescribePost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionDescribePostRequest

	// ApiV1XcherryServiceProcessExecutionDescribePostExecute executes the request
	//  @return ProcessExecutionDescribeResponse
	ApiV1XcherryServiceProcessExecutionDescribePostExecute(r ApiApiV1XcherryServiceProcessExecutionDescribePostRequest) (*ProcessExecutionDescribeResponse, *http.Response, error)

	/*
		ApiV1XcherryServiceProcessExecutionListPost list process executions

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionListPostRequest
	*/
	ApiV1XcherryServiceProcessExecutionListPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionListPostRequest

	// ApiV1XcherryServiceProcessExecutionListPostExecute executes the request
	//  @return ListProcessExecutionsResponse
	ApiV1XcherryServiceProcessExecutionListPostExecute(r ApiApiV1XcherryServiceProcessExecutionListPostRequest) (*ListProcessExecutionsResponse, *http.Response, error)

	/*
		ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePost send message(s) to be consumed within a single process execution

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest
	*/
	ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest

	// ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostExecute executes the request
	ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostExecute(r ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest) (*http.Response, error)

	/*
		ApiV1XcherryServiceProcessExecutionRpcPost execute a RPC method of a process execution

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionRpcPostRequest
	*/
	ApiV1XcherryServiceProcessExecutionRpcPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionRpcPostRequest

	// ApiV1XcherryServiceProcessExecutionRpcPostExecute executes the request
	//  @return ProcessExecutionRpcResponse
	ApiV1XcherryServiceProcessExecutionRpcPostExecute(r ApiApiV1XcherryServiceProcessExecutionRpcPostRequest) (*ProcessExecutionRpcResponse, *http.Response, error)

	/*
		ApiV1XcherryServiceProcessExecutionStartPost start a process execution

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionStartPostRequest
	*/
	ApiV1XcherryServiceProcessExecutionStartPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionStartPostRequest

	// ApiV1XcherryServiceProcessExecutionStartPostExecute executes the request
	//  @return ProcessExecutionStartResponse
	ApiV1XcherryServiceProcessExecutionStartPostExecute(r ApiApiV1XcherryServiceProcessExecutionStartPostRequest) (*ProcessExecutionStartResponse, *http.Response, error)

	/*
		ApiV1XcherryServiceProcessExecutionStopPost stop a process execution

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionStopPostRequest
	*/
	ApiV1XcherryServiceProcessExecutionStopPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionStopPostRequest

	// ApiV1XcherryServiceProcessExecutionStopPostExecute executes the request
	ApiV1XcherryServiceProcessExecutionStopPostExecute(r ApiApiV1XcherryServiceProcessExecutionStopPostRequest) (*http.Response, error)

	/*
		ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPost wait for a process completion

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest
	*/
	ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest

	// ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostExecute executes the request
	//  @return ProcessExecutionWaitForCompletionResponse
	ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostExecute(r ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest) (*ProcessExecutionWaitForCompletionResponse, *http.Response, error)

	/*
		ApiV1XcherryWorkerAsyncStateExecutePost invoking AsyncState.execute API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryWorkerAsyncStateExecutePostRequest
	*/
	ApiV1XcherryWorkerAsyncStateExecutePost(ctx context.Context) ApiApiV1XcherryWorkerAsyncStateExecutePostRequest

	// ApiV1XcherryWorkerAsyncStateExecutePostExecute executes the request
	//  @return AsyncStateExecuteResponse
	ApiV1XcherryWorkerAsyncStateExecutePostExecute(r ApiApiV1XcherryWorkerAsyncStateExecutePostRequest) (*AsyncStateExecuteResponse, *http.Response, error)

	/*
		ApiV1XcherryWorkerAsyncStateWaitUntilPost invoking AsyncState.waitUntil API

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest
	*/
	ApiV1XcherryWorkerAsyncStateWaitUntilPost(ctx context.Context) ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest

	// ApiV1XcherryWorkerAsyncStateWaitUntilPostExecute executes the request
	//  @return AsyncStateWaitUntilResponse
	ApiV1XcherryWorkerAsyncStateWaitUntilPostExecute(r ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest) (*AsyncStateWaitUntilResponse, *http.Response, error)

	/*
		ApiV1XcherryWorkerProcessRpcPost execute a RPC method of a process execution in the worker

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiApiV1XcherryWorkerProcessRpcPostRequest
	*/
	ApiV1XcherryWorkerProcessRpcPost(ctx context.Context) ApiApiV1XcherryWorkerProcessRpcPostRequest

	// ApiV1XcherryWorkerProcessRpcPostExecute executes the request
	//  @return ProcessRpcWorkerResponse
	ApiV1XcherryWorkerProcessRpcPostExecute(r ApiApiV1XcherryWorkerProcessRpcPostRequest) (*ProcessRpcWorkerResponse, *http.Response, error)

	/*
		InternalApiV1XcherryNotifyImmediateTasksPost for api service to tell async service that there are new immediate tasks added to the queue

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest
	*/
	InternalApiV1XcherryNotifyImmediateTasksPost(ctx context.Context) ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest

	// InternalApiV1XcherryNotifyImmediateTasksPostExecute executes the request
	InternalApiV1XcherryNotifyImmediateTasksPostExecute(r ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest) (*http.Response, error)

	/*
		InternalApiV1XcherryNotifyTimerTasksPost for api service to tell async service that there are new timer tasks added to the queue

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiInternalApiV1XcherryNotifyTimerTasksPostRequest
	*/
	InternalApiV1XcherryNotifyTimerTasksPost(ctx context.Context) ApiInternalApiV1XcherryNotifyTimerTasksPostRequest

	// InternalApiV1XcherryNotifyTimerTasksPostExecute executes the request
	InternalApiV1XcherryNotifyTimerTasksPostExecute(r ApiInternalApiV1XcherryNotifyTimerTasksPostRequest) (*http.Response, error)

	/*
		InternalApiV1XcherrySignalProcessCompletionPost for async service to signal for process completion

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiInternalApiV1XcherrySignalProcessCompletionPostRequest
	*/
	InternalApiV1XcherrySignalProcessCompletionPost(ctx context.Context) ApiInternalApiV1XcherrySignalProcessCompletionPostRequest

	// InternalApiV1XcherrySignalProcessCompletionPostExecute executes the request
	InternalApiV1XcherrySignalProcessCompletionPostExecute(r ApiInternalApiV1XcherrySignalProcessCompletionPostRequest) (*http.Response, error)

	/*
		InternalApiV1XcherryWaitForProcessCompletionPost for api service to ask async service to wait for process completion

		@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
		@return ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest
	*/
	InternalApiV1XcherryWaitForProcessCompletionPost(ctx context.Context) ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest

	// InternalApiV1XcherryWaitForProcessCompletionPostExecute executes the request
	//  @return WaitForProcessCompletionResponse
	InternalApiV1XcherryWaitForProcessCompletionPostExecute(r ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest) (*WaitForProcessCompletionResponse, *http.Response, error)
}

// DefaultAPIService DefaultAPI service
type DefaultAPIService service

type ApiApiV1XcherryServiceProcessExecutionDescribePostRequest struct {
	ctx                             context.Context
	ApiService                      DefaultAPI
	processExecutionDescribeRequest *ProcessExecutionDescribeRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionDescribePostRequest) ProcessExecutionDescribeRequest(processExecutionDescribeRequest ProcessExecutionDescribeRequest) ApiApiV1XcherryServiceProcessExecutionDescribePostRequest {
	r.processExecutionDescribeRequest = &processExecutionDescribeRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionDescribePostRequest) Execute() (*ProcessExecutionDescribeResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionDescribePostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionDescribePost describe a process execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionDescribePostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionDescribePost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionDescribePostRequest {
	return ApiApiV1XcherryServiceProcessExecutionDescribePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProcessExecutionDescribeResponse
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionDescribePostExecute(r ApiApiV1XcherryServiceProcessExecutionDescribePostRequest) (*ProcessExecutionDescribeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessExecutionDescribeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionDescribePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/describe"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processExecutionDescribeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryServiceProcessExecutionListPostRequest struct {
	ctx                          context.Context
	ApiService                   DefaultAPI
	listProcessExecutionsRequest *ListProcessExecutionsRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionListPostRequest) ListProcessExecutionsRequest(listProcessExecutionsRequest ListProcessExecutionsRequest) ApiApiV1XcherryServiceProcessExecutionListPostRequest {
	r.listProcessExecutionsRequest = &listProcessExecutionsRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionListPostRequest) Execute() (*ListProcessExecutionsResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionListPostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionListPost list process executions

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionListPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionListPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionListPostRequest {
	return ApiApiV1XcherryServiceProcessExecutionListPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ListProcessExecutionsResponse
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionListPostExecute(r ApiApiV1XcherryServiceProcessExecutionListPostRequest) (*ListProcessExecutionsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ListProcessExecutionsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.listProcessExecutionsRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest struct {
	ctx                        context.Context
	ApiService                 DefaultAPI
	publishToLocalQueueRequest *PublishToLocalQueueRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest) PublishToLocalQueueRequest(publishToLocalQueueRequest PublishToLocalQueueRequest) ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest {
	r.publishToLocalQueueRequest = &publishToLocalQueueRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePost send message(s) to be consumed within a single process execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest {
	return ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostExecute(r ApiApiV1XcherryServiceProcessExecutionPublishToLocalQueuePostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionPublishToLocalQueuePost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/publish-to-local-queue"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.publishToLocalQueueRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV1XcherryServiceProcessExecutionRpcPostRequest struct {
	ctx                        context.Context
	ApiService                 DefaultAPI
	processExecutionRpcRequest *ProcessExecutionRpcRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionRpcPostRequest) ProcessExecutionRpcRequest(processExecutionRpcRequest ProcessExecutionRpcRequest) ApiApiV1XcherryServiceProcessExecutionRpcPostRequest {
	r.processExecutionRpcRequest = &processExecutionRpcRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionRpcPostRequest) Execute() (*ProcessExecutionRpcResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionRpcPostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionRpcPost execute a RPC method of a process execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionRpcPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionRpcPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionRpcPostRequest {
	return ApiApiV1XcherryServiceProcessExecutionRpcPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProcessExecutionRpcResponse
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionRpcPostExecute(r ApiApiV1XcherryServiceProcessExecutionRpcPostRequest) (*ProcessExecutionRpcResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessExecutionRpcResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionRpcPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/rpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processExecutionRpcRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryServiceProcessExecutionStartPostRequest struct {
	ctx                          context.Context
	ApiService                   DefaultAPI
	processExecutionStartRequest *ProcessExecutionStartRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionStartPostRequest) ProcessExecutionStartRequest(processExecutionStartRequest ProcessExecutionStartRequest) ApiApiV1XcherryServiceProcessExecutionStartPostRequest {
	r.processExecutionStartRequest = &processExecutionStartRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionStartPostRequest) Execute() (*ProcessExecutionStartResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionStartPostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionStartPost start a process execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionStartPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionStartPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionStartPostRequest {
	return ApiApiV1XcherryServiceProcessExecutionStartPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProcessExecutionStartResponse
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionStartPostExecute(r ApiApiV1XcherryServiceProcessExecutionStartPostRequest) (*ProcessExecutionStartResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessExecutionStartResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionStartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processExecutionStartRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryServiceProcessExecutionStopPostRequest struct {
	ctx                         context.Context
	ApiService                  DefaultAPI
	processExecutionStopRequest *ProcessExecutionStopRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionStopPostRequest) ProcessExecutionStopRequest(processExecutionStopRequest ProcessExecutionStopRequest) ApiApiV1XcherryServiceProcessExecutionStopPostRequest {
	r.processExecutionStopRequest = &processExecutionStopRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionStopPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionStopPostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionStopPost stop a process execution

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionStopPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionStopPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionStopPostRequest {
	return ApiApiV1XcherryServiceProcessExecutionStopPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionStopPostExecute(r ApiApiV1XcherryServiceProcessExecutionStopPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionStopPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/stop"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processExecutionStopRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest struct {
	ctx                                      context.Context
	ApiService                               DefaultAPI
	processExecutionWaitForCompletionRequest *ProcessExecutionWaitForCompletionRequest
}

func (r ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest) ProcessExecutionWaitForCompletionRequest(processExecutionWaitForCompletionRequest ProcessExecutionWaitForCompletionRequest) ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest {
	r.processExecutionWaitForCompletionRequest = &processExecutionWaitForCompletionRequest
	return r
}

func (r ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest) Execute() (*ProcessExecutionWaitForCompletionResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostExecute(r)
}

/*
ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPost wait for a process completion

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPost(ctx context.Context) ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest {
	return ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProcessExecutionWaitForCompletionResponse
func (a *DefaultAPIService) ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostExecute(r ApiApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPostRequest) (*ProcessExecutionWaitForCompletionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessExecutionWaitForCompletionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryServiceProcessExecutionWaitForProcessCompletionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/service/process-execution/wait-for-process-completion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processExecutionWaitForCompletionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		var v ApiErrorResponse
		err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			newErr.error = err.Error()
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
		newErr.model = v
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryWorkerAsyncStateExecutePostRequest struct {
	ctx                      context.Context
	ApiService               DefaultAPI
	asyncStateExecuteRequest *AsyncStateExecuteRequest
}

func (r ApiApiV1XcherryWorkerAsyncStateExecutePostRequest) AsyncStateExecuteRequest(asyncStateExecuteRequest AsyncStateExecuteRequest) ApiApiV1XcherryWorkerAsyncStateExecutePostRequest {
	r.asyncStateExecuteRequest = &asyncStateExecuteRequest
	return r
}

func (r ApiApiV1XcherryWorkerAsyncStateExecutePostRequest) Execute() (*AsyncStateExecuteResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryWorkerAsyncStateExecutePostExecute(r)
}

/*
ApiV1XcherryWorkerAsyncStateExecutePost invoking AsyncState.execute API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryWorkerAsyncStateExecutePostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryWorkerAsyncStateExecutePost(ctx context.Context) ApiApiV1XcherryWorkerAsyncStateExecutePostRequest {
	return ApiApiV1XcherryWorkerAsyncStateExecutePostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AsyncStateExecuteResponse
func (a *DefaultAPIService) ApiV1XcherryWorkerAsyncStateExecutePostExecute(r ApiApiV1XcherryWorkerAsyncStateExecutePostRequest) (*AsyncStateExecuteResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncStateExecuteResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryWorkerAsyncStateExecutePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/worker/async-state/execute"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.asyncStateExecuteRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 406 {
			var v AppDatabaseErrorHandling
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 424 {
			var v WorkerErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest struct {
	ctx                        context.Context
	ApiService                 DefaultAPI
	asyncStateWaitUntilRequest *AsyncStateWaitUntilRequest
}

func (r ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest) AsyncStateWaitUntilRequest(asyncStateWaitUntilRequest AsyncStateWaitUntilRequest) ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest {
	r.asyncStateWaitUntilRequest = &asyncStateWaitUntilRequest
	return r
}

func (r ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest) Execute() (*AsyncStateWaitUntilResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryWorkerAsyncStateWaitUntilPostExecute(r)
}

/*
ApiV1XcherryWorkerAsyncStateWaitUntilPost invoking AsyncState.waitUntil API

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryWorkerAsyncStateWaitUntilPost(ctx context.Context) ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest {
	return ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return AsyncStateWaitUntilResponse
func (a *DefaultAPIService) ApiV1XcherryWorkerAsyncStateWaitUntilPostExecute(r ApiApiV1XcherryWorkerAsyncStateWaitUntilPostRequest) (*AsyncStateWaitUntilResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *AsyncStateWaitUntilResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryWorkerAsyncStateWaitUntilPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/worker/async-state/wait-until"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.asyncStateWaitUntilRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 424 {
			var v WorkerErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiApiV1XcherryWorkerProcessRpcPostRequest struct {
	ctx                     context.Context
	ApiService              DefaultAPI
	processRpcWorkerRequest *ProcessRpcWorkerRequest
}

func (r ApiApiV1XcherryWorkerProcessRpcPostRequest) ProcessRpcWorkerRequest(processRpcWorkerRequest ProcessRpcWorkerRequest) ApiApiV1XcherryWorkerProcessRpcPostRequest {
	r.processRpcWorkerRequest = &processRpcWorkerRequest
	return r
}

func (r ApiApiV1XcherryWorkerProcessRpcPostRequest) Execute() (*ProcessRpcWorkerResponse, *http.Response, error) {
	return r.ApiService.ApiV1XcherryWorkerProcessRpcPostExecute(r)
}

/*
ApiV1XcherryWorkerProcessRpcPost execute a RPC method of a process execution in the worker

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiApiV1XcherryWorkerProcessRpcPostRequest
*/
func (a *DefaultAPIService) ApiV1XcherryWorkerProcessRpcPost(ctx context.Context) ApiApiV1XcherryWorkerProcessRpcPostRequest {
	return ApiApiV1XcherryWorkerProcessRpcPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return ProcessRpcWorkerResponse
func (a *DefaultAPIService) ApiV1XcherryWorkerProcessRpcPostExecute(r ApiApiV1XcherryWorkerProcessRpcPostRequest) (*ProcessRpcWorkerResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *ProcessRpcWorkerResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.ApiV1XcherryWorkerProcessRpcPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/xcherry/worker/process/rpc"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.processRpcWorkerRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 424 {
			var v WorkerErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest struct {
	ctx                         context.Context
	ApiService                  DefaultAPI
	notifyImmediateTasksRequest *NotifyImmediateTasksRequest
}

func (r ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest) NotifyImmediateTasksRequest(notifyImmediateTasksRequest NotifyImmediateTasksRequest) ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest {
	r.notifyImmediateTasksRequest = &notifyImmediateTasksRequest
	return r
}

func (r ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InternalApiV1XcherryNotifyImmediateTasksPostExecute(r)
}

/*
InternalApiV1XcherryNotifyImmediateTasksPost for api service to tell async service that there are new immediate tasks added to the queue

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest
*/
func (a *DefaultAPIService) InternalApiV1XcherryNotifyImmediateTasksPost(ctx context.Context) ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest {
	return ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) InternalApiV1XcherryNotifyImmediateTasksPostExecute(r ApiInternalApiV1XcherryNotifyImmediateTasksPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InternalApiV1XcherryNotifyImmediateTasksPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/api/v1/xcherry/notify-immediate-tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notifyImmediateTasksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInternalApiV1XcherryNotifyTimerTasksPostRequest struct {
	ctx                     context.Context
	ApiService              DefaultAPI
	notifyTimerTasksRequest *NotifyTimerTasksRequest
}

func (r ApiInternalApiV1XcherryNotifyTimerTasksPostRequest) NotifyTimerTasksRequest(notifyTimerTasksRequest NotifyTimerTasksRequest) ApiInternalApiV1XcherryNotifyTimerTasksPostRequest {
	r.notifyTimerTasksRequest = &notifyTimerTasksRequest
	return r
}

func (r ApiInternalApiV1XcherryNotifyTimerTasksPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InternalApiV1XcherryNotifyTimerTasksPostExecute(r)
}

/*
InternalApiV1XcherryNotifyTimerTasksPost for api service to tell async service that there are new timer tasks added to the queue

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalApiV1XcherryNotifyTimerTasksPostRequest
*/
func (a *DefaultAPIService) InternalApiV1XcherryNotifyTimerTasksPost(ctx context.Context) ApiInternalApiV1XcherryNotifyTimerTasksPostRequest {
	return ApiInternalApiV1XcherryNotifyTimerTasksPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) InternalApiV1XcherryNotifyTimerTasksPostExecute(r ApiInternalApiV1XcherryNotifyTimerTasksPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InternalApiV1XcherryNotifyTimerTasksPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/api/v1/xcherry/notify-timer-tasks"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.notifyTimerTasksRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInternalApiV1XcherrySignalProcessCompletionPostRequest struct {
	ctx                            context.Context
	ApiService                     DefaultAPI
	signalProcessCompletionRequest *SignalProcessCompletionRequest
}

func (r ApiInternalApiV1XcherrySignalProcessCompletionPostRequest) SignalProcessCompletionRequest(signalProcessCompletionRequest SignalProcessCompletionRequest) ApiInternalApiV1XcherrySignalProcessCompletionPostRequest {
	r.signalProcessCompletionRequest = &signalProcessCompletionRequest
	return r
}

func (r ApiInternalApiV1XcherrySignalProcessCompletionPostRequest) Execute() (*http.Response, error) {
	return r.ApiService.InternalApiV1XcherrySignalProcessCompletionPostExecute(r)
}

/*
InternalApiV1XcherrySignalProcessCompletionPost for async service to signal for process completion

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalApiV1XcherrySignalProcessCompletionPostRequest
*/
func (a *DefaultAPIService) InternalApiV1XcherrySignalProcessCompletionPost(ctx context.Context) ApiInternalApiV1XcherrySignalProcessCompletionPostRequest {
	return ApiInternalApiV1XcherrySignalProcessCompletionPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
func (a *DefaultAPIService) InternalApiV1XcherrySignalProcessCompletionPostExecute(r ApiInternalApiV1XcherrySignalProcessCompletionPostRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod = http.MethodPost
		localVarPostBody   interface{}
		formFiles          []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InternalApiV1XcherrySignalProcessCompletionPost")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/api/v1/xcherry/signal-process-completion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.signalProcessCompletionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest struct {
	ctx                             context.Context
	ApiService                      DefaultAPI
	waitForProcessCompletionRequest *WaitForProcessCompletionRequest
}

func (r ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest) WaitForProcessCompletionRequest(waitForProcessCompletionRequest WaitForProcessCompletionRequest) ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest {
	r.waitForProcessCompletionRequest = &waitForProcessCompletionRequest
	return r
}

func (r ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest) Execute() (*WaitForProcessCompletionResponse, *http.Response, error) {
	return r.ApiService.InternalApiV1XcherryWaitForProcessCompletionPostExecute(r)
}

/*
InternalApiV1XcherryWaitForProcessCompletionPost for api service to ask async service to wait for process completion

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@return ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest
*/
func (a *DefaultAPIService) InternalApiV1XcherryWaitForProcessCompletionPost(ctx context.Context) ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest {
	return ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest{
		ApiService: a,
		ctx:        ctx,
	}
}

// Execute executes the request
//
//	@return WaitForProcessCompletionResponse
func (a *DefaultAPIService) InternalApiV1XcherryWaitForProcessCompletionPostExecute(r ApiInternalApiV1XcherryWaitForProcessCompletionPostRequest) (*WaitForProcessCompletionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod  = http.MethodPost
		localVarPostBody    interface{}
		formFiles           []formFile
		localVarReturnValue *WaitForProcessCompletionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "DefaultAPIService.InternalApiV1XcherryWaitForProcessCompletionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/internal/api/v1/xcherry/wait-for-process-completion"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.waitForProcessCompletionRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
