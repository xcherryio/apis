/* tslint:disable */
/* eslint-disable */
/**
 * xCherry APIs
 * This APIs between xCherry service and SDKs
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
    /**
     * 
     * @type {ErrorSubType}
     * @memberof ApiErrorResponse
     */
    'errorSubType'?: ErrorSubType;
    /**
     * for WORKER_EXECUTION_ERROR, it\'s the value from WorkerErrorResponse.errorType; for APP_DATABASE_READ/WRITE_ERROR, it\'s the error code from database driver
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'appErrorType'?: string;
    /**
     * for WORKER_EXECUTION_ERROR, it\'s the value from WorkerErrorResponse.details; for APP_DATABASE_READ/WRITE_ERROR, it\'s the error message from database driver; for other apiErrorType, it\'s the detailed message from server.
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'details'?: string;
}


/**
 * the value of a table column (from SDK to server or from server to SDK)
 * @export
 * @interface AppDatabaseColumnValue
 */
export interface AppDatabaseColumnValue {
    /**
     * the column name that can be used in the database query, see below for example
     * @type {string}
     * @memberof AppDatabaseColumnValue
     */
    'column': string;
    /**
     * the plain string value that can be used in the database query(e.g. for SQL SELECT ... WHERE $Column=$dbQueryValue or UPDATE/INSERT)
     * @type {string}
     * @memberof AppDatabaseColumnValue
     */
    'queryValue': string;
}
/**
 * the configuration of what tables and rows to read/load for state/RPCs, including an optional initial write
 * @export
 * @interface AppDatabaseConfig
 */
export interface AppDatabaseConfig {
    /**
     * 
     * @type {Array<AppDatabaseTableConfig>}
     * @memberof AppDatabaseConfig
     */
    'tables'?: Array<AppDatabaseTableConfig>;
}
/**
 * the request to read the selected rows of configured app database tables
 * @export
 * @interface AppDatabaseReadRequest
 */
export interface AppDatabaseReadRequest {
    /**
     * 
     * @type {Array<AppDatabaseTableReadRequest>}
     * @memberof AppDatabaseReadRequest
     */
    'tableRequests'?: Array<AppDatabaseTableReadRequest>;
}
/**
 * the response for read the app database
 * @export
 * @interface AppDatabaseReadResponse
 */
export interface AppDatabaseReadResponse {
    /**
     * 
     * @type {Array<AppDatabaseTableReadResponse>}
     * @memberof AppDatabaseReadResponse
     */
    'tables'?: Array<AppDatabaseTableReadResponse>;
    /**
     * 
     * @type {ErrorSubType}
     * @memberof AppDatabaseReadResponse
     */
    'appDBErrorType'?: ErrorSubType;
    /**
     * the error code from database driver
     * @type {string}
     * @memberof AppDatabaseReadResponse
     */
    'appDBErrorCode'?: string;
    /**
     * the error message from database driver
     * @type {string}
     * @memberof AppDatabaseReadResponse
     */
    'appDBErrorMessage'?: string;
    /**
     * the first table that encounters the error to help SDK to throw the error in a friendly way 
     * @type {string}
     * @memberof AppDatabaseReadResponse
     */
    'appDBErrorTableName'?: string;
}


/**
 * 
 * @export
 * @interface AppDatabaseRowReadResponse
 */
export interface AppDatabaseRowReadResponse {
    /**
     * 
     * @type {Array<AppDatabaseColumnValue>}
     * @memberof AppDatabaseRowReadResponse
     */
    'columns'?: Array<AppDatabaseColumnValue>;
}
/**
 * 
 * @export
 * @interface AppDatabaseRowWrite
 */
export interface AppDatabaseRowWrite {
    /**
     * the PK to locate the rows for write
     * @type {Array<AppDatabaseColumnValue>}
     * @memberof AppDatabaseRowWrite
     */
    'primaryKey': Array<AppDatabaseColumnValue>;
    /**
     * 
     * @type {Array<AppDatabaseColumnValue>}
     * @memberof AppDatabaseRowWrite
     */
    'writeColumns': Array<AppDatabaseColumnValue>;
}
/**
 * 
 * @export
 * @interface AppDatabaseTableConfig
 */
export interface AppDatabaseTableConfig {
    /**
     * 
     * @type {string}
     * @memberof AppDatabaseTableConfig
     */
    'tableName': string;
    /**
     * 
     * @type {Array<AppDatabaseTableRowSelector>}
     * @memberof AppDatabaseTableConfig
     */
    'rows': Array<AppDatabaseTableRowSelector>;
}
/**
 * 
 * @export
 * @interface AppDatabaseTableReadRequest
 */
export interface AppDatabaseTableReadRequest {
    /**
     * 
     * @type {string}
     * @memberof AppDatabaseTableReadRequest
     */
    'tableName'?: string;
    /**
     * 
     * @type {DatabaseLockingType}
     * @memberof AppDatabaseTableReadRequest
     */
    'lockType'?: DatabaseLockingType;
    /**
     * 
     * @type {Array<string>}
     * @memberof AppDatabaseTableReadRequest
     */
    'columns'?: Array<string>;
}


/**
 * 
 * @export
 * @interface AppDatabaseTableReadResponse
 */
export interface AppDatabaseTableReadResponse {
    /**
     * 
     * @type {string}
     * @memberof AppDatabaseTableReadResponse
     */
    'tableName'?: string;
    /**
     * 
     * @type {Array<AppDatabaseRowReadResponse>}
     * @memberof AppDatabaseTableReadResponse
     */
    'rows'?: Array<AppDatabaseRowReadResponse>;
}
/**
 * 
 * @export
 * @interface AppDatabaseTableRowSelector
 */
export interface AppDatabaseTableRowSelector {
    /**
     * 
     * @type {Array<AppDatabaseColumnValue>}
     * @memberof AppDatabaseTableRowSelector
     */
    'primaryKey': Array<AppDatabaseColumnValue>;
    /**
     * 
     * @type {Array<AppDatabaseColumnValue>}
     * @memberof AppDatabaseTableRowSelector
     */
    'initialWrite'?: Array<AppDatabaseColumnValue>;
    /**
     * 
     * @type {WriteConflictMode}
     * @memberof AppDatabaseTableRowSelector
     */
    'conflictMode'?: WriteConflictMode;
}


/**
 * 
 * @export
 * @interface AppDatabaseTableWrite
 */
export interface AppDatabaseTableWrite {
    /**
     * 
     * @type {string}
     * @memberof AppDatabaseTableWrite
     */
    'tableName': string;
    /**
     * 
     * @type {Array<AppDatabaseRowWrite>}
     * @memberof AppDatabaseTableWrite
     */
    'rows'?: Array<AppDatabaseRowWrite>;
}
/**
 * the write operation for state/RPCs to write to the app database values
 * @export
 * @interface AppDatabaseWrite
 */
export interface AppDatabaseWrite {
    /**
     * 
     * @type {Array<AppDatabaseTableWrite>}
     * @memberof AppDatabaseWrite
     */
    'tables'?: Array<AppDatabaseTableWrite>;
}
/**
 * 
 * @export
 * @interface AsyncStateConfig
 */
export interface AsyncStateConfig {
    /**
     * 
     * @type {boolean}
     * @memberof AsyncStateConfig
     */
    'skipWaitUntil'?: boolean;
    /**
     * the timeout for the single attempt of AsyncState.waitUntil API
     * @type {number}
     * @memberof AsyncStateConfig
     */
    'waitUntilApiTimeoutSeconds'?: number;
    /**
     * the timeout for the single attempt of AsyncState.execute API
     * @type {number}
     * @memberof AsyncStateConfig
     */
    'executeApiTimeoutSeconds'?: number;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof AsyncStateConfig
     */
    'waitUntilApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof AsyncStateConfig
     */
    'executeApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {StateFailureRecoveryOptions}
     * @memberof AsyncStateConfig
     */
    'stateFailureRecoveryOptions'?: StateFailureRecoveryOptions;
    /**
     * 
     * @type {AppDatabaseTableReadRequest}
     * @memberof AsyncStateConfig
     */
    'appDatabaseReadRequest'?: AppDatabaseTableReadRequest;
    /**
     * 
     * @type {LoadLocalAttributesRequest}
     * @memberof AsyncStateConfig
     */
    'loadLocalAttributesRequest'?: LoadLocalAttributesRequest;
}
/**
 * the input of the execute API
 * @export
 * @interface AsyncStateExecuteRequest
 */
export interface AsyncStateExecuteRequest {
    /**
     * 
     * @type {Context}
     * @memberof AsyncStateExecuteRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateExecuteRequest
     */
    'processType': string;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateExecuteRequest
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof AsyncStateExecuteRequest
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {CommandResults}
     * @memberof AsyncStateExecuteRequest
     */
    'commandResults'?: CommandResults;
    /**
     * 
     * @type {AppDatabaseReadResponse}
     * @memberof AsyncStateExecuteRequest
     */
    'readAppDatabaseResponse'?: AppDatabaseReadResponse;
    /**
     * 
     * @type {LoadLocalAttributesResponse}
     * @memberof AsyncStateExecuteRequest
     */
    'loadedLocalAttributes'?: LoadLocalAttributesResponse;
}
/**
 * the output of the execute API
 * @export
 * @interface AsyncStateExecuteResponse
 */
export interface AsyncStateExecuteResponse {
    /**
     * 
     * @type {StateDecision}
     * @memberof AsyncStateExecuteResponse
     */
    'stateDecision': StateDecision;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof AsyncStateExecuteResponse
     */
    'publishToLocalQueue'?: Array<LocalQueueMessage>;
    /**
     * 
     * @type {AppDatabaseWrite}
     * @memberof AsyncStateExecuteResponse
     */
    'writeToAppDatabase'?: AppDatabaseWrite;
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof AsyncStateExecuteResponse
     */
    'writeToLocalAttributes'?: Array<KeyValue>;
}
/**
 * the input of the waitUntil API
 * @export
 * @interface AsyncStateWaitUntilRequest
 */
export interface AsyncStateWaitUntilRequest {
    /**
     * 
     * @type {Context}
     * @memberof AsyncStateWaitUntilRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateWaitUntilRequest
     */
    'processType': string;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateWaitUntilRequest
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof AsyncStateWaitUntilRequest
     */
    'stateInput'?: EncodedObject;
}
/**
 * the output of the waitUntil API
 * @export
 * @interface AsyncStateWaitUntilResponse
 */
export interface AsyncStateWaitUntilResponse {
    /**
     * 
     * @type {CommandRequest}
     * @memberof AsyncStateWaitUntilResponse
     */
    'commandRequest': CommandRequest;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof AsyncStateWaitUntilResponse
     */
    'publishToLocalQueue'?: Array<LocalQueueMessage>;
}
/**
 * 
 * @export
 * @interface CommandRequest
 */
export interface CommandRequest {
    /**
     * 
     * @type {CommandWaitingType}
     * @memberof CommandRequest
     */
    'waitingType': CommandWaitingType;
    /**
     * 
     * @type {Array<TimerCommand>}
     * @memberof CommandRequest
     */
    'timerCommands'?: Array<TimerCommand>;
    /**
     * 
     * @type {Array<LocalQueueCommand>}
     * @memberof CommandRequest
     */
    'localQueueCommands'?: Array<LocalQueueCommand>;
}


/**
 * 
 * @export
 * @interface CommandResults
 */
export interface CommandResults {
    /**
     * 
     * @type {Array<TimerResult>}
     * @memberof CommandResults
     */
    'timerResults'?: Array<TimerResult>;
    /**
     * 
     * @type {Array<LocalQueueResult>}
     * @memberof CommandResults
     */
    'localQueueResults'?: Array<LocalQueueResult>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommandStatus = {
    WaitingCommand: 'WAITING_COMMAND',
    CompletedCommand: 'COMPLETED_COMMAND',
    SkippedCommand: 'SKIPPED_COMMAND'
} as const;

export type CommandStatus = typeof CommandStatus[keyof typeof CommandStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CommandWaitingType = {
    EmptyCommand: 'EmptyCommand',
    AnyOfCompletion: 'AnyOfCompletion',
    AllOfCompletion: 'AllOfCompletion'
} as const;

export type CommandWaitingType = typeof CommandWaitingType[keyof typeof CommandWaitingType];


/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'processId': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'processExecutionId': string;
    /**
     * 
     * @type {number}
     * @memberof Context
     */
    'processStartedTimestamp': number;
    /**
     * stateExecutionId is for async state API only
     * @type {string}
     * @memberof Context
     */
    'stateExecutionId'?: string;
    /**
     * for async state API only(during backoff retry)
     * @type {number}
     * @memberof Context
     */
    'firstAttemptTimestamp'?: number;
    /**
     * for async state API only(during backoff retry)
     * @type {number}
     * @memberof Context
     */
    'attempt'?: number;
    /**
     * for async state API only, state id + sequence number
     * @type {string}
     * @memberof Context
     */
    'recoverFromStateExecutionId'?: string;
    /**
     * 
     * @type {WorkerApiType}
     * @memberof Context
     */
    'recoverFromApi'?: WorkerApiType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const DatabaseLockingType = {
    NoLocking: 'NO_LOCKING',
    ShareLock: 'SHARE_LOCK',
    ExclusiveLock: 'EXCLUSIVE_LOCK'
} as const;

export type DatabaseLockingType = typeof DatabaseLockingType[keyof typeof DatabaseLockingType];


/**
 * 
 * @export
 * @interface EncodedObject
 */
export interface EncodedObject {
    /**
     * 
     * @type {string}
     * @memberof EncodedObject
     */
    'encoding': string;
    /**
     * 
     * @type {string}
     * @memberof EncodedObject
     */
    'data': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ErrorSubType = {
    UncategorizedError: 'UNCATEGORIZED_ERROR',
    WorkerExecutionError: 'WORKER_EXECUTION_ERROR',
    AppDatabaseReadError: 'APP_DATABASE_READ_ERROR',
    AppDatabaseWriteError: 'APP_DATABASE_WRITE_ERROR',
    PollTimeoutError: 'POLL_TIMEOUT_ERROR'
} as const;

export type ErrorSubType = typeof ErrorSubType[keyof typeof ErrorSubType];


/**
 * 
 * @export
 * @interface KeyValue
 */
export interface KeyValue {
    /**
     * 
     * @type {string}
     * @memberof KeyValue
     */
    'key': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof KeyValue
     */
    'value': EncodedObject;
}
/**
 * 
 * @export
 * @interface LoadLocalAttributesRequest
 */
export interface LoadLocalAttributesRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof LoadLocalAttributesRequest
     */
    'keysToLoadNoLock'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof LoadLocalAttributesRequest
     */
    'keysToLoadWithLock'?: Array<string>;
    /**
     * 
     * @type {DatabaseLockingType}
     * @memberof LoadLocalAttributesRequest
     */
    'lockType'?: DatabaseLockingType;
}


/**
 * 
 * @export
 * @interface LoadLocalAttributesResponse
 */
export interface LoadLocalAttributesResponse {
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof LoadLocalAttributesResponse
     */
    'attributes'?: Array<KeyValue>;
}
/**
 * 
 * @export
 * @interface LocalAttributeConfig
 */
export interface LocalAttributeConfig {
    /**
     * 
     * @type {Array<KeyValue>}
     * @memberof LocalAttributeConfig
     */
    'initialWrite'?: Array<KeyValue>;
}
/**
 * 
 * @export
 * @interface LocalQueueCommand
 */
export interface LocalQueueCommand {
    /**
     * 
     * @type {string}
     * @memberof LocalQueueCommand
     */
    'queueName': string;
    /**
     * the number of identical messages to await
     * @type {number}
     * @memberof LocalQueueCommand
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface LocalQueueMessage
 */
export interface LocalQueueMessage {
    /**
     * 
     * @type {string}
     * @memberof LocalQueueMessage
     */
    'queueName': string;
    /**
     * UUID to uniquely distinguish different messages. If not specified, the server will generate a UUID instead.
     * @type {string}
     * @memberof LocalQueueMessage
     */
    'dedupId'?: string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof LocalQueueMessage
     */
    'payload'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface LocalQueueMessageResult
 */
export interface LocalQueueMessageResult {
    /**
     * UUID to uniquely distinguish different messages.
     * @type {string}
     * @memberof LocalQueueMessageResult
     */
    'dedupId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof LocalQueueMessageResult
     */
    'payload'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface LocalQueueResult
 */
export interface LocalQueueResult {
    /**
     * 
     * @type {CommandStatus}
     * @memberof LocalQueueResult
     */
    'status': CommandStatus;
    /**
     * 
     * @type {string}
     * @memberof LocalQueueResult
     */
    'queueName': string;
    /**
     * 
     * @type {Array<LocalQueueMessageResult>}
     * @memberof LocalQueueResult
     */
    'messages'?: Array<LocalQueueMessageResult>;
}


/**
 * 
 * @export
 * @interface NotifyImmediateTasksRequest
 */
export interface NotifyImmediateTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof NotifyImmediateTasksRequest
     */
    'shardId': number;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyImmediateTasksRequest
     */
    'namespace'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyImmediateTasksRequest
     */
    'processId'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyImmediateTasksRequest
     */
    'processExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface NotifyTimerTasksRequest
 */
export interface NotifyTimerTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof NotifyTimerTasksRequest
     */
    'shardId': number;
    /**
     * the fire timestamp of all timer tasks to pull
     * @type {Array<number>}
     * @memberof NotifyTimerTasksRequest
     */
    'fireTimestamps': Array<number>;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyTimerTasksRequest
     */
    'namespace'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyTimerTasksRequest
     */
    'processId'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyTimerTasksRequest
     */
    'processExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface ProcessExecutionDescribeRequest
 */
export interface ProcessExecutionDescribeRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionDescribeRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionDescribeRequest
     */
    'processId': string;
}
/**
 * 
 * @export
 * @interface ProcessExecutionDescribeResponse
 */
export interface ProcessExecutionDescribeResponse {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionDescribeResponse
     */
    'processExecutionId'?: string;
    /**
     * the process type for SDK to lookup the process definition class
     * @type {string}
     * @memberof ProcessExecutionDescribeResponse
     */
    'processType'?: string;
    /**
     * the URL for xcherry async service to make callback to worker
     * @type {string}
     * @memberof ProcessExecutionDescribeResponse
     */
    'workerUrl'?: string;
    /**
     * start time of the process execution
     * @type {number}
     * @memberof ProcessExecutionDescribeResponse
     */
    'startTimestamp'?: number;
    /**
     * 
     * @type {ProcessStatus}
     * @memberof ProcessExecutionDescribeResponse
     */
    'status'?: ProcessStatus;
}


/**
 * the request for executing a RPC method of a process execution
 * @export
 * @interface ProcessExecutionRpcRequest
 */
export interface ProcessExecutionRpcRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionRpcRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionRpcRequest
     */
    'processId': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionRpcRequest
     */
    'rpcName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof ProcessExecutionRpcRequest
     */
    'input'?: EncodedObject;
    /**
     * the timeout for the single attempt of the Process RPC API
     * @type {number}
     * @memberof ProcessExecutionRpcRequest
     */
    'timeoutSeconds'?: number;
    /**
     * 
     * @type {AppDatabaseReadRequest}
     * @memberof ProcessExecutionRpcRequest
     */
    'appDatabaseReadRequest'?: AppDatabaseReadRequest;
}
/**
 * the response for executing a RPC method of a process execution
 * @export
 * @interface ProcessExecutionRpcResponse
 */
export interface ProcessExecutionRpcResponse {
    /**
     * 
     * @type {EncodedObject}
     * @memberof ProcessExecutionRpcResponse
     */
    'output'?: EncodedObject;
}
/**
 * the request for starting a process execution
 * @export
 * @interface ProcessExecutionStartRequest
 */
export interface ProcessExecutionStartRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'namespace': string;
    /**
     * the user business identifier for the process, which can be used for multiple ProcessExecution based on ProcessIdReusePolicy
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'processId': string;
    /**
     * the process type for SDK to lookup the process definition class
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'processType': string;
    /**
     * the URL for xcherry async service to make callback to worker
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'workerUrl': string;
    /**
     * StateId of the first AsyncState to start
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'startStateId'?: string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof ProcessExecutionStartRequest
     */
    'startStateInput'?: EncodedObject;
    /**
     * 
     * @type {AsyncStateConfig}
     * @memberof ProcessExecutionStartRequest
     */
    'startStateConfig'?: AsyncStateConfig;
    /**
     * 
     * @type {ProcessStartConfig}
     * @memberof ProcessExecutionStartRequest
     */
    'processStartConfig'?: ProcessStartConfig;
}
/**
 * response of ProcessExecutionStartRequest
 * @export
 * @interface ProcessExecutionStartResponse
 */
export interface ProcessExecutionStartResponse {
    /**
     * a UUID as the unique identifier of a process execution
     * @type {string}
     * @memberof ProcessExecutionStartResponse
     */
    'processExecutionId': string;
}
/**
 * the request for stopping a process execution
 * @export
 * @interface ProcessExecutionStopRequest
 */
export interface ProcessExecutionStopRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionStopRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionStopRequest
     */
    'processId': string;
    /**
     * 
     * @type {ProcessExecutionStopType}
     * @memberof ProcessExecutionStopRequest
     */
    'stopType'?: ProcessExecutionStopType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessExecutionStopType = {
    Terminate: 'TERMINATE',
    Fail: 'FAIL'
} as const;

export type ProcessExecutionStopType = typeof ProcessExecutionStopType[keyof typeof ProcessExecutionStopType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessIdReusePolicy = {
    AllowIfPreviousExitAbnormally: 'ALLOW_IF_PREVIOUS_EXIT_ABNORMALLY',
    AllowIfNoRunning: 'ALLOW_IF_NO_RUNNING',
    DisallowReuse: 'DISALLOW_REUSE',
    TerminateIfRunning: 'TERMINATE_IF_RUNNING'
} as const;

export type ProcessIdReusePolicy = typeof ProcessIdReusePolicy[keyof typeof ProcessIdReusePolicy];


/**
 * the request of the worker RPC API
 * @export
 * @interface ProcessRpcWorkerRequest
 */
export interface ProcessRpcWorkerRequest {
    /**
     * 
     * @type {Context}
     * @memberof ProcessRpcWorkerRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof ProcessRpcWorkerRequest
     */
    'processType': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessRpcWorkerRequest
     */
    'rpcName': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof ProcessRpcWorkerRequest
     */
    'input'?: EncodedObject;
    /**
     * 
     * @type {AppDatabaseReadResponse}
     * @memberof ProcessRpcWorkerRequest
     */
    'appDatabaseReadResponse'?: AppDatabaseReadResponse;
}
/**
 * the response of the worker RPC API
 * @export
 * @interface ProcessRpcWorkerResponse
 */
export interface ProcessRpcWorkerResponse {
    /**
     * 
     * @type {EncodedObject}
     * @memberof ProcessRpcWorkerResponse
     */
    'output'?: EncodedObject;
    /**
     * 
     * @type {StateDecision}
     * @memberof ProcessRpcWorkerResponse
     */
    'stateDecision': StateDecision;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof ProcessRpcWorkerResponse
     */
    'publishToLocalQueue'?: Array<LocalQueueMessage>;
    /**
     * 
     * @type {AppDatabaseWrite}
     * @memberof ProcessRpcWorkerResponse
     */
    'writeToAppDatabase'?: AppDatabaseWrite;
}
/**
 * 
 * @export
 * @interface ProcessStartConfig
 */
export interface ProcessStartConfig {
    /**
     * 
     * @type {number}
     * @memberof ProcessStartConfig
     */
    'timeoutSeconds'?: number;
    /**
     * 
     * @type {ProcessIdReusePolicy}
     * @memberof ProcessStartConfig
     */
    'idReusePolicy'?: ProcessIdReusePolicy;
    /**
     * 
     * @type {AppDatabaseConfig}
     * @memberof ProcessStartConfig
     */
    'appDatabaseConfig'?: AppDatabaseConfig;
    /**
     * 
     * @type {LocalAttributeConfig}
     * @memberof ProcessStartConfig
     */
    'localAttributeConfig'?: LocalAttributeConfig;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessStatus = {
    Running: 'RUNNING',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    Terminated: 'TERMINATED'
} as const;

export type ProcessStatus = typeof ProcessStatus[keyof typeof ProcessStatus];


/**
 * the request for sending messages to be consumed within a single process execution
 * @export
 * @interface PublishToLocalQueueRequest
 */
export interface PublishToLocalQueueRequest {
    /**
     * 
     * @type {string}
     * @memberof PublishToLocalQueueRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof PublishToLocalQueueRequest
     */
    'processId': string;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof PublishToLocalQueueRequest
     */
    'messages'?: Array<LocalQueueMessage>;
}
/**
 * 
 * @export
 * @interface RetryPolicy
 */
export interface RetryPolicy {
    /**
     * the initial interval for the first retry, default to 1 second
     * @type {number}
     * @memberof RetryPolicy
     */
    'initialIntervalSeconds'?: number;
    /**
     * the backoff coefficient for the next retry, default to 2
     * @type {number}
     * @memberof RetryPolicy
     */
    'backoffCoefficient'?: number;
    /**
     * the maximum interval for the next retry, default to 100x of initial interval
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumIntervalSeconds'?: number;
    /**
     * the maximum number of attempts, default to 0, means unlimited
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumAttempts'?: number;
    /**
     * the maximum duration of all attempts, default to 0, means unlimited
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumAttemptsDurationSeconds'?: number;
}
/**
 * the decision at the end of state execution, either nextStates or threadCloseDecision is needed
 * @export
 * @interface StateDecision
 */
export interface StateDecision {
    /**
     * 
     * @type {Array<StateMovement>}
     * @memberof StateDecision
     */
    'nextStates'?: Array<StateMovement>;
    /**
     * 
     * @type {ThreadCloseDecision}
     * @memberof StateDecision
     */
    'threadCloseDecision'?: ThreadCloseDecision;
}
/**
 * 
 * @export
 * @interface StateFailureRecoveryOptions
 */
export interface StateFailureRecoveryOptions {
    /**
     * 
     * @type {StateFailureRecoveryPolicy}
     * @memberof StateFailureRecoveryOptions
     */
    'policy': StateFailureRecoveryPolicy;
    /**
     * 
     * @type {string}
     * @memberof StateFailureRecoveryOptions
     */
    'stateFailureProceedStateId'?: string;
    /**
     * 
     * @type {AsyncStateConfig}
     * @memberof StateFailureRecoveryOptions
     */
    'stateFailureProceedStateConfig'?: AsyncStateConfig;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StateFailureRecoveryPolicy = {
    FailProcessOnStateFailure: 'FAIL_PROCESS_ON_STATE_FAILURE',
    ProceedToConfiguredState: 'PROCEED_TO_CONFIGURED_STATE'
} as const;

export type StateFailureRecoveryPolicy = typeof StateFailureRecoveryPolicy[keyof typeof StateFailureRecoveryPolicy];


/**
 * 
 * @export
 * @interface StateMovement
 */
export interface StateMovement {
    /**
     * 
     * @type {string}
     * @memberof StateMovement
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof StateMovement
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {AsyncStateConfig}
     * @memberof StateMovement
     */
    'stateConfig'?: AsyncStateConfig;
}
/**
 * 
 * @export
 * @interface ThreadCloseDecision
 */
export interface ThreadCloseDecision {
    /**
     * 
     * @type {ThreadCloseType}
     * @memberof ThreadCloseDecision
     */
    'closeType': ThreadCloseType;
    /**
     * 
     * @type {EncodedObject}
     * @memberof ThreadCloseDecision
     */
    'closeInput'?: EncodedObject;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ThreadCloseType = {
    ForceCompleteProcess: 'FORCE_COMPLETE_PROCESS',
    GracefulCompleteProcess: 'GRACEFUL_COMPLETE_PROCESS',
    DeadEnd: 'DEAD_END',
    ForceFailProcess: 'FORCE_FAIL_PROCESS'
} as const;

export type ThreadCloseType = typeof ThreadCloseType[keyof typeof ThreadCloseType];


/**
 * 
 * @export
 * @interface TimerCommand
 */
export interface TimerCommand {
    /**
     * 
     * @type {number}
     * @memberof TimerCommand
     */
    'delayInSeconds': number;
}
/**
 * 
 * @export
 * @interface TimerResult
 */
export interface TimerResult {
    /**
     * 
     * @type {CommandStatus}
     * @memberof TimerResult
     */
    'status': CommandStatus;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const WorkerApiType = {
    WaitUntilApi: 'WAIT_UNTIL_API',
    ExecuteApi: 'EXECUTE_API',
    RpcApi: 'RPC_API'
} as const;

export type WorkerApiType = typeof WorkerApiType[keyof typeof WorkerApiType];


/**
 * 
 * @export
 * @interface WorkerErrorResponse
 */
export interface WorkerErrorResponse {
    /**
     * an optional field to let application set some detailed information. Default to the error message + stacktrace of the error
     * @type {string}
     * @memberof WorkerErrorResponse
     */
    'detail'?: string;
    /**
     * an optional field for error handling. Default to the class/error Name
     * @type {string}
     * @memberof WorkerErrorResponse
     */
    'errorType': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const WriteConflictMode = {
    ReturnErrorOnConflict: 'RETURN_ERROR_ON_CONFLICT',
    IgnoreConflict: 'IGNORE_CONFLICT',
    OverrideOnConflict: 'OVERRIDE_ON_CONFLICT'
} as const;

export type WriteConflictMode = typeof WriteConflictMode[keyof typeof WriteConflictMode];



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary describe a process execution
         * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionDescribePost: async (processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/service/process-execution/describe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionDescribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary send message(s) to be consumed within a single process execution
         * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost: async (publishToLocalQueueRequest?: PublishToLocalQueueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/service/process-execution/publish-to-local-queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishToLocalQueueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary execute a RPC method of a process execution
         * @param {ProcessExecutionRpcRequest} [processExecutionRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionRpcPost: async (processExecutionRpcRequest?: ProcessExecutionRpcRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/service/process-execution/rpc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionRpcRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary start a process execution
         * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionStartPost: async (processExecutionStartRequest?: ProcessExecutionStartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/service/process-execution/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stop a process execution
         * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionStopPost: async (processExecutionStopRequest?: ProcessExecutionStopRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/service/process-execution/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionStopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary invoking AsyncState.execute API
         * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryWorkerAsyncStateExecutePost: async (asyncStateExecuteRequest?: AsyncStateExecuteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/worker/async-state/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asyncStateExecuteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary invoking AsyncState.waitUntil API
         * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryWorkerAsyncStateWaitUntilPost: async (asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/worker/async-state/wait-until`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asyncStateWaitUntilRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary execute a RPC method of a process execution in the worker
         * @param {ProcessRpcWorkerRequest} [processRpcWorkerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryWorkerProcessRpcPost: async (processRpcWorkerRequest?: ProcessRpcWorkerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xcherry/worker/process/rpc`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processRpcWorkerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for api service to tell async service that there are new immediate tasks added to the queue
         * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XcherryNotifyImmediateTasksPost: async (notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/api/v1/xcherry/notify-immediate-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyImmediateTasksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for api service to tell async service that there are new timer tasks added to the queue
         * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XcherryNotifyTimerTasksPost: async (notifyTimerTasksRequest?: NotifyTimerTasksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/api/v1/xcherry/notify-timer-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyTimerTasksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary describe a process execution
         * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryServiceProcessExecutionDescribePost(processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessExecutionDescribeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryServiceProcessExecutionDescribePost(processExecutionDescribeRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryServiceProcessExecutionDescribePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary send message(s) to be consumed within a single process execution
         * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest?: PublishToLocalQueueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary execute a RPC method of a process execution
         * @param {ProcessExecutionRpcRequest} [processExecutionRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryServiceProcessExecutionRpcPost(processExecutionRpcRequest?: ProcessExecutionRpcRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessExecutionRpcResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryServiceProcessExecutionRpcPost(processExecutionRpcRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryServiceProcessExecutionRpcPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary start a process execution
         * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryServiceProcessExecutionStartPost(processExecutionStartRequest?: ProcessExecutionStartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessExecutionStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryServiceProcessExecutionStartPost(processExecutionStartRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryServiceProcessExecutionStartPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary stop a process execution
         * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryServiceProcessExecutionStopPost(processExecutionStopRequest?: ProcessExecutionStopRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryServiceProcessExecutionStopPost(processExecutionStopRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryServiceProcessExecutionStopPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary invoking AsyncState.execute API
         * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryWorkerAsyncStateExecutePost(asyncStateExecuteRequest?: AsyncStateExecuteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncStateExecuteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryWorkerAsyncStateExecutePost(asyncStateExecuteRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryWorkerAsyncStateExecutePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary invoking AsyncState.waitUntil API
         * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncStateWaitUntilResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryWorkerAsyncStateWaitUntilPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary execute a RPC method of a process execution in the worker
         * @param {ProcessRpcWorkerRequest} [processRpcWorkerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XcherryWorkerProcessRpcPost(processRpcWorkerRequest?: ProcessRpcWorkerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessRpcWorkerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XcherryWorkerProcessRpcPost(processRpcWorkerRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.apiV1XcherryWorkerProcessRpcPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary for api service to tell async service that there are new immediate tasks added to the queue
         * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internalApiV1XcherryNotifyImmediateTasksPost(notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internalApiV1XcherryNotifyImmediateTasksPost(notifyImmediateTasksRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.internalApiV1XcherryNotifyImmediateTasksPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary for api service to tell async service that there are new timer tasks added to the queue
         * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internalApiV1XcherryNotifyTimerTasksPost(notifyTimerTasksRequest?: NotifyTimerTasksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internalApiV1XcherryNotifyTimerTasksPost(notifyTimerTasksRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.internalApiV1XcherryNotifyTimerTasksPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary describe a process execution
         * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionDescribePost(processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options?: any): AxiosPromise<ProcessExecutionDescribeResponse> {
            return localVarFp.apiV1XcherryServiceProcessExecutionDescribePost(processExecutionDescribeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary send message(s) to be consumed within a single process execution
         * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest?: PublishToLocalQueueRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary execute a RPC method of a process execution
         * @param {ProcessExecutionRpcRequest} [processExecutionRpcRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionRpcPost(processExecutionRpcRequest?: ProcessExecutionRpcRequest, options?: any): AxiosPromise<ProcessExecutionRpcResponse> {
            return localVarFp.apiV1XcherryServiceProcessExecutionRpcPost(processExecutionRpcRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary start a process execution
         * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionStartPost(processExecutionStartRequest?: ProcessExecutionStartRequest, options?: any): AxiosPromise<ProcessExecutionStartResponse> {
            return localVarFp.apiV1XcherryServiceProcessExecutionStartPost(processExecutionStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stop a process execution
         * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryServiceProcessExecutionStopPost(processExecutionStopRequest?: ProcessExecutionStopRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1XcherryServiceProcessExecutionStopPost(processExecutionStopRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary invoking AsyncState.execute API
         * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryWorkerAsyncStateExecutePost(asyncStateExecuteRequest?: AsyncStateExecuteRequest, options?: any): AxiosPromise<AsyncStateExecuteResponse> {
            return localVarFp.apiV1XcherryWorkerAsyncStateExecutePost(asyncStateExecuteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary invoking AsyncState.waitUntil API
         * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options?: any): AxiosPromise<AsyncStateWaitUntilResponse> {
            return localVarFp.apiV1XcherryWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary execute a RPC method of a process execution in the worker
         * @param {ProcessRpcWorkerRequest} [processRpcWorkerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XcherryWorkerProcessRpcPost(processRpcWorkerRequest?: ProcessRpcWorkerRequest, options?: any): AxiosPromise<ProcessRpcWorkerResponse> {
            return localVarFp.apiV1XcherryWorkerProcessRpcPost(processRpcWorkerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for api service to tell async service that there are new immediate tasks added to the queue
         * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XcherryNotifyImmediateTasksPost(notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options?: any): AxiosPromise<void> {
            return localVarFp.internalApiV1XcherryNotifyImmediateTasksPost(notifyImmediateTasksRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for api service to tell async service that there are new timer tasks added to the queue
         * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XcherryNotifyTimerTasksPost(notifyTimerTasksRequest?: NotifyTimerTasksRequest, options?: any): AxiosPromise<void> {
            return localVarFp.internalApiV1XcherryNotifyTimerTasksPost(notifyTimerTasksRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary describe a process execution
     * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryServiceProcessExecutionDescribePost(processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryServiceProcessExecutionDescribePost(processExecutionDescribeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary send message(s) to be consumed within a single process execution
     * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest?: PublishToLocalQueueRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary execute a RPC method of a process execution
     * @param {ProcessExecutionRpcRequest} [processExecutionRpcRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryServiceProcessExecutionRpcPost(processExecutionRpcRequest?: ProcessExecutionRpcRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryServiceProcessExecutionRpcPost(processExecutionRpcRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary start a process execution
     * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryServiceProcessExecutionStartPost(processExecutionStartRequest?: ProcessExecutionStartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryServiceProcessExecutionStartPost(processExecutionStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stop a process execution
     * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryServiceProcessExecutionStopPost(processExecutionStopRequest?: ProcessExecutionStopRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryServiceProcessExecutionStopPost(processExecutionStopRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary invoking AsyncState.execute API
     * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryWorkerAsyncStateExecutePost(asyncStateExecuteRequest?: AsyncStateExecuteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryWorkerAsyncStateExecutePost(asyncStateExecuteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary invoking AsyncState.waitUntil API
     * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary execute a RPC method of a process execution in the worker
     * @param {ProcessRpcWorkerRequest} [processRpcWorkerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XcherryWorkerProcessRpcPost(processRpcWorkerRequest?: ProcessRpcWorkerRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XcherryWorkerProcessRpcPost(processRpcWorkerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for api service to tell async service that there are new immediate tasks added to the queue
     * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public internalApiV1XcherryNotifyImmediateTasksPost(notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).internalApiV1XcherryNotifyImmediateTasksPost(notifyImmediateTasksRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for api service to tell async service that there are new timer tasks added to the queue
     * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public internalApiV1XcherryNotifyTimerTasksPost(notifyTimerTasksRequest?: NotifyTimerTasksRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).internalApiV1XcherryNotifyTimerTasksPost(notifyTimerTasksRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



