/* tslint:disable */
/* eslint-disable */
/**
 * XDB APIs
 * This APIs between xdb service and SDKs
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'originalWorkerErrorDetail'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'originalWorkerErrorType'?: string;
    /**
     * 
     * @type {number}
     * @memberof ApiErrorResponse
     */
    'originalWorkerErrorStatus'?: number;
}
/**
 * 
 * @export
 * @interface AsyncStateConfig
 */
export interface AsyncStateConfig {
    /**
     * 
     * @type {boolean}
     * @memberof AsyncStateConfig
     */
    'skipWaitUntil'?: boolean;
    /**
     * the timeout for the single attempt of AsyncState.waitUntil API
     * @type {number}
     * @memberof AsyncStateConfig
     */
    'waitUntilApiTimeoutSeconds'?: number;
    /**
     * the timeout for the single attempt of AsyncState.execute API
     * @type {number}
     * @memberof AsyncStateConfig
     */
    'executeApiTimeoutSeconds'?: number;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof AsyncStateConfig
     */
    'waitUntilApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {RetryPolicy}
     * @memberof AsyncStateConfig
     */
    'executeApiRetryPolicy'?: RetryPolicy;
    /**
     * 
     * @type {StateFailureRecoveryOptions}
     * @memberof AsyncStateConfig
     */
    'stateFailureRecoveryOptions'?: StateFailureRecoveryOptions;
    /**
     * 
     * @type {LoadGlobalAttributesRequest}
     * @memberof AsyncStateConfig
     */
    'loadGlobalAttributesRequest'?: LoadGlobalAttributesRequest;
}
/**
 * the input of the execute API
 * @export
 * @interface AsyncStateExecuteRequest
 */
export interface AsyncStateExecuteRequest {
    /**
     * 
     * @type {Context}
     * @memberof AsyncStateExecuteRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateExecuteRequest
     */
    'processType': string;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateExecuteRequest
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof AsyncStateExecuteRequest
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {CommandResults}
     * @memberof AsyncStateExecuteRequest
     */
    'commandResults'?: CommandResults;
    /**
     * 
     * @type {LoadGlobalAttributeResponse}
     * @memberof AsyncStateExecuteRequest
     */
    'loadedGlobalAttributes'?: LoadGlobalAttributeResponse;
}
/**
 * the output of the execute API
 * @export
 * @interface AsyncStateExecuteResponse
 */
export interface AsyncStateExecuteResponse {
    /**
     * 
     * @type {StateDecision}
     * @memberof AsyncStateExecuteResponse
     */
    'stateDecision': StateDecision;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof AsyncStateExecuteResponse
     */
    'publishToLocalQueue'?: Array<LocalQueueMessage>;
    /**
     * 
     * @type {Array<GlobalAttributeTableRowUpdate>}
     * @memberof AsyncStateExecuteResponse
     */
    'writeToGlobalAttributes'?: Array<GlobalAttributeTableRowUpdate>;
}
/**
 * the input of the waitUntil API
 * @export
 * @interface AsyncStateWaitUntilRequest
 */
export interface AsyncStateWaitUntilRequest {
    /**
     * 
     * @type {Context}
     * @memberof AsyncStateWaitUntilRequest
     */
    'context': Context;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateWaitUntilRequest
     */
    'processType': string;
    /**
     * 
     * @type {string}
     * @memberof AsyncStateWaitUntilRequest
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof AsyncStateWaitUntilRequest
     */
    'stateInput'?: EncodedObject;
}
/**
 * the output of the waitUntil API
 * @export
 * @interface AsyncStateWaitUntilResponse
 */
export interface AsyncStateWaitUntilResponse {
    /**
     * 
     * @type {CommandRequest}
     * @memberof AsyncStateWaitUntilResponse
     */
    'commandRequest': CommandRequest;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof AsyncStateWaitUntilResponse
     */
    'publishToLocalQueue'?: Array<LocalQueueMessage>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AttributeWriteConflictMode = {
    ReturnErrorOnConflict: 'RETURN_ERROR_ON_CONFLICT',
    IgnoreConflict: 'IGNORE_CONFLICT',
    OverrideOnConflict: 'OVERRIDE_ON_CONFLICT'
} as const;

export type AttributeWriteConflictMode = typeof AttributeWriteConflictMode[keyof typeof AttributeWriteConflictMode];


/**
 * 
 * @export
 * @interface CommandRequest
 */
export interface CommandRequest {
    /**
     * 
     * @type {CommandWaitingType}
     * @memberof CommandRequest
     */
    'waitingType': CommandWaitingType;
    /**
     * 
     * @type {Array<TimerCommand>}
     * @memberof CommandRequest
     */
    'timerCommands'?: Array<TimerCommand>;
    /**
     * 
     * @type {Array<LocalQueueCommand>}
     * @memberof CommandRequest
     */
    'localQueueCommands'?: Array<LocalQueueCommand>;
}


/**
 * 
 * @export
 * @interface CommandResults
 */
export interface CommandResults {
    /**
     * 
     * @type {Array<TimerResult>}
     * @memberof CommandResults
     */
    'timerResults'?: Array<TimerResult>;
    /**
     * 
     * @type {Array<LocalQueueResult>}
     * @memberof CommandResults
     */
    'localQueueResults'?: Array<LocalQueueResult>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommandStatus = {
    WaitingCommand: 'WAITING_COMMAND',
    CompletedCommand: 'COMPLETED_COMMAND',
    SkippedCommand: 'SKIPPED_COMMAND'
} as const;

export type CommandStatus = typeof CommandStatus[keyof typeof CommandStatus];


/**
 * 
 * @export
 * @enum {string}
 */

export const CommandWaitingType = {
    EmptyCommand: 'EmptyCommand',
    AnyOfCompletion: 'AnyOfCompletion',
    AllOfCompletion: 'AllOfCompletion'
} as const;

export type CommandWaitingType = typeof CommandWaitingType[keyof typeof CommandWaitingType];


/**
 * 
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'processId': string;
    /**
     * 
     * @type {string}
     * @memberof Context
     */
    'processExecutionId': string;
    /**
     * 
     * @type {number}
     * @memberof Context
     */
    'processStartedTimestamp': number;
    /**
     * stateExecutionId is for async state API only
     * @type {string}
     * @memberof Context
     */
    'stateExecutionId'?: string;
    /**
     * for async state API only(during backoff retry)
     * @type {number}
     * @memberof Context
     */
    'firstAttemptTimestamp'?: number;
    /**
     * for async state API only(during backoff retry)
     * @type {number}
     * @memberof Context
     */
    'attempt'?: number;
    /**
     * for async state API only, state id + sequence number
     * @type {string}
     * @memberof Context
     */
    'recoverFromStateExecutionId'?: string;
    /**
     * 
     * @type {StateApiType}
     * @memberof Context
     */
    'recoverFromApi'?: StateApiType;
}


/**
 * 
 * @export
 * @interface EncodedObject
 */
export interface EncodedObject {
    /**
     * 
     * @type {string}
     * @memberof EncodedObject
     */
    'encoding': string;
    /**
     * 
     * @type {string}
     * @memberof EncodedObject
     */
    'data': string;
}
/**
 * 
 * @export
 * @interface GlobalAttributeConfig
 */
export interface GlobalAttributeConfig {
    /**
     * 
     * @type {Array<GlobalAttributeTableConfig>}
     * @memberof GlobalAttributeConfig
     */
    'tableConfigs'?: Array<GlobalAttributeTableConfig>;
}
/**
 * 
 * @export
 * @interface GlobalAttributeTableConfig
 */
export interface GlobalAttributeTableConfig {
    /**
     * 
     * @type {string}
     * @memberof GlobalAttributeTableConfig
     */
    'tableName': string;
    /**
     * 
     * @type {TableColumnValue}
     * @memberof GlobalAttributeTableConfig
     */
    'primaryKey': TableColumnValue;
    /**
     * 
     * @type {Array<TableColumnValue>}
     * @memberof GlobalAttributeTableConfig
     */
    'initialWrite'?: Array<TableColumnValue>;
    /**
     * 
     * @type {AttributeWriteConflictMode}
     * @memberof GlobalAttributeTableConfig
     */
    'initialWriteMode'?: AttributeWriteConflictMode;
}


/**
 * 
 * @export
 * @interface GlobalAttributeTableRowUpdate
 */
export interface GlobalAttributeTableRowUpdate {
    /**
     * 
     * @type {string}
     * @memberof GlobalAttributeTableRowUpdate
     */
    'tableName': string;
    /**
     * 
     * @type {Array<TableColumnValue>}
     * @memberof GlobalAttributeTableRowUpdate
     */
    'updateColumns'?: Array<TableColumnValue>;
}
/**
 * the response for loading global attributes
 * @export
 * @interface LoadGlobalAttributeResponse
 */
export interface LoadGlobalAttributeResponse {
    /**
     * 
     * @type {Array<TableReadResponse>}
     * @memberof LoadGlobalAttributeResponse
     */
    'tableResponses'?: Array<TableReadResponse>;
}
/**
 * the request to load global attributes
 * @export
 * @interface LoadGlobalAttributesRequest
 */
export interface LoadGlobalAttributesRequest {
    /**
     * 
     * @type {Array<TableReadRequest>}
     * @memberof LoadGlobalAttributesRequest
     */
    'tableRequests'?: Array<TableReadRequest>;
}
/**
 * 
 * @export
 * @interface LocalQueueCommand
 */
export interface LocalQueueCommand {
    /**
     * 
     * @type {string}
     * @memberof LocalQueueCommand
     */
    'queueName': string;
    /**
     * the number of identical messages to await
     * @type {number}
     * @memberof LocalQueueCommand
     */
    'count'?: number;
}
/**
 * 
 * @export
 * @interface LocalQueueMessage
 */
export interface LocalQueueMessage {
    /**
     * 
     * @type {string}
     * @memberof LocalQueueMessage
     */
    'queueName': string;
    /**
     * UUID to uniquely distinguish different messages. If not specified, the server will generate a UUID instead.
     * @type {string}
     * @memberof LocalQueueMessage
     */
    'dedupId'?: string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof LocalQueueMessage
     */
    'payload'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface LocalQueueMessageResult
 */
export interface LocalQueueMessageResult {
    /**
     * UUID to uniquely distinguish different messages.
     * @type {string}
     * @memberof LocalQueueMessageResult
     */
    'dedupId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof LocalQueueMessageResult
     */
    'payload'?: EncodedObject;
}
/**
 * 
 * @export
 * @interface LocalQueueResult
 */
export interface LocalQueueResult {
    /**
     * 
     * @type {CommandStatus}
     * @memberof LocalQueueResult
     */
    'status': CommandStatus;
    /**
     * 
     * @type {string}
     * @memberof LocalQueueResult
     */
    'queueName': string;
    /**
     * 
     * @type {Array<LocalQueueMessageResult>}
     * @memberof LocalQueueResult
     */
    'messages'?: Array<LocalQueueMessageResult>;
}


/**
 * 
 * @export
 * @interface NotifyImmediateTasksRequest
 */
export interface NotifyImmediateTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof NotifyImmediateTasksRequest
     */
    'shardId': number;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyImmediateTasksRequest
     */
    'namespace'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyImmediateTasksRequest
     */
    'processId'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyImmediateTasksRequest
     */
    'processExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface NotifyTimerTasksRequest
 */
export interface NotifyTimerTasksRequest {
    /**
     * 
     * @type {number}
     * @memberof NotifyTimerTasksRequest
     */
    'shardId': number;
    /**
     * the fire timestamp of all timer tasks to pull
     * @type {Array<number>}
     * @memberof NotifyTimerTasksRequest
     */
    'fireTimestamps': Array<number>;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyTimerTasksRequest
     */
    'namespace'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyTimerTasksRequest
     */
    'processId'?: string;
    /**
     * optional field for distributed database without global secondary index, to pull for specific task rather than a page
     * @type {string}
     * @memberof NotifyTimerTasksRequest
     */
    'processExecutionId'?: string;
}
/**
 * 
 * @export
 * @interface ProcessExecutionDescribeRequest
 */
export interface ProcessExecutionDescribeRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionDescribeRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionDescribeRequest
     */
    'processId': string;
}
/**
 * 
 * @export
 * @interface ProcessExecutionDescribeResponse
 */
export interface ProcessExecutionDescribeResponse {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionDescribeResponse
     */
    'processExecutionId'?: string;
    /**
     * the process type for SDK to lookup the process definition class
     * @type {string}
     * @memberof ProcessExecutionDescribeResponse
     */
    'processType'?: string;
    /**
     * the URL for XDB async service to make callback to worker
     * @type {string}
     * @memberof ProcessExecutionDescribeResponse
     */
    'workerUrl'?: string;
    /**
     * start time of the process execution
     * @type {number}
     * @memberof ProcessExecutionDescribeResponse
     */
    'startTimestamp'?: number;
    /**
     * 
     * @type {ProcessStatus}
     * @memberof ProcessExecutionDescribeResponse
     */
    'status'?: ProcessStatus;
}


/**
 * the request for starting a process execution
 * @export
 * @interface ProcessExecutionStartRequest
 */
export interface ProcessExecutionStartRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'namespace': string;
    /**
     * the user business identifier for the process, which can be used for multiple ProcessExecution based on ProcessIdReusePolicy
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'processId': string;
    /**
     * the process type for SDK to lookup the process definition class
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'processType': string;
    /**
     * the URL for XDB async service to make callback to worker
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'workerUrl': string;
    /**
     * StateId of the first AsyncState to start
     * @type {string}
     * @memberof ProcessExecutionStartRequest
     */
    'startStateId'?: string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof ProcessExecutionStartRequest
     */
    'startStateInput'?: EncodedObject;
    /**
     * 
     * @type {AsyncStateConfig}
     * @memberof ProcessExecutionStartRequest
     */
    'startStateConfig'?: AsyncStateConfig;
    /**
     * 
     * @type {ProcessStartConfig}
     * @memberof ProcessExecutionStartRequest
     */
    'processStartConfig'?: ProcessStartConfig;
}
/**
 * response of ProcessExecutionStartRequest
 * @export
 * @interface ProcessExecutionStartResponse
 */
export interface ProcessExecutionStartResponse {
    /**
     * a UUID as the unique identifier of a process execution
     * @type {string}
     * @memberof ProcessExecutionStartResponse
     */
    'processExecutionId': string;
}
/**
 * the request for stopping a process execution
 * @export
 * @interface ProcessExecutionStopRequest
 */
export interface ProcessExecutionStopRequest {
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionStopRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof ProcessExecutionStopRequest
     */
    'processId': string;
    /**
     * 
     * @type {ProcessExecutionStopType}
     * @memberof ProcessExecutionStopRequest
     */
    'stopType'?: ProcessExecutionStopType;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessExecutionStopType = {
    Terminate: 'TERMINATE',
    Fail: 'FAIL'
} as const;

export type ProcessExecutionStopType = typeof ProcessExecutionStopType[keyof typeof ProcessExecutionStopType];


/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessIdReusePolicy = {
    AllowIfPreviousExitAbnormally: 'ALLOW_IF_PREVIOUS_EXIT_ABNORMALLY',
    AllowIfNoRunning: 'ALLOW_IF_NO_RUNNING',
    DisallowReuse: 'DISALLOW_REUSE',
    TerminateIfRunning: 'TERMINATE_IF_RUNNING'
} as const;

export type ProcessIdReusePolicy = typeof ProcessIdReusePolicy[keyof typeof ProcessIdReusePolicy];


/**
 * 
 * @export
 * @interface ProcessStartConfig
 */
export interface ProcessStartConfig {
    /**
     * 
     * @type {number}
     * @memberof ProcessStartConfig
     */
    'timeoutSeconds'?: number;
    /**
     * 
     * @type {ProcessIdReusePolicy}
     * @memberof ProcessStartConfig
     */
    'idReusePolicy'?: ProcessIdReusePolicy;
    /**
     * 
     * @type {GlobalAttributeConfig}
     * @memberof ProcessStartConfig
     */
    'globalAttributeConfig'?: GlobalAttributeConfig;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ProcessStatus = {
    Running: 'RUNNING',
    Completed: 'COMPLETED',
    Failed: 'FAILED',
    Timeout: 'TIMEOUT',
    Terminated: 'TERMINATED'
} as const;

export type ProcessStatus = typeof ProcessStatus[keyof typeof ProcessStatus];


/**
 * the request for sending messages to be consumed within a single process execution
 * @export
 * @interface PublishToLocalQueueRequest
 */
export interface PublishToLocalQueueRequest {
    /**
     * 
     * @type {string}
     * @memberof PublishToLocalQueueRequest
     */
    'namespace': string;
    /**
     * 
     * @type {string}
     * @memberof PublishToLocalQueueRequest
     */
    'processId': string;
    /**
     * 
     * @type {Array<LocalQueueMessage>}
     * @memberof PublishToLocalQueueRequest
     */
    'messages'?: Array<LocalQueueMessage>;
}
/**
 * 
 * @export
 * @interface RetryPolicy
 */
export interface RetryPolicy {
    /**
     * the initial interval for the first retry, default to 1 second
     * @type {number}
     * @memberof RetryPolicy
     */
    'initialIntervalSeconds'?: number;
    /**
     * the backoff coefficient for the next retry, default to 2
     * @type {number}
     * @memberof RetryPolicy
     */
    'backoffCoefficient'?: number;
    /**
     * the maximum interval for the next retry, default to 100x of initial interval
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumIntervalSeconds'?: number;
    /**
     * the maximum number of attempts, default to 0, means unlimited
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumAttempts'?: number;
    /**
     * the maximum duration of all attempts, default to 0, means unlimited
     * @type {number}
     * @memberof RetryPolicy
     */
    'maximumAttemptsDurationSeconds'?: number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StateApiType = {
    WaitUntilApi: 'WAIT_UNTIL_API',
    ExecuteApi: 'EXECUTE_API'
} as const;

export type StateApiType = typeof StateApiType[keyof typeof StateApiType];


/**
 * the decision at the end of state execution, either nextStates or threadCloseDecision is needed
 * @export
 * @interface StateDecision
 */
export interface StateDecision {
    /**
     * 
     * @type {Array<StateMovement>}
     * @memberof StateDecision
     */
    'nextStates'?: Array<StateMovement>;
    /**
     * 
     * @type {ThreadCloseDecision}
     * @memberof StateDecision
     */
    'threadCloseDecision'?: ThreadCloseDecision;
}
/**
 * 
 * @export
 * @interface StateFailureRecoveryOptions
 */
export interface StateFailureRecoveryOptions {
    /**
     * 
     * @type {StateFailureRecoveryPolicy}
     * @memberof StateFailureRecoveryOptions
     */
    'policy': StateFailureRecoveryPolicy;
    /**
     * 
     * @type {string}
     * @memberof StateFailureRecoveryOptions
     */
    'stateFailureProceedStateId'?: string;
    /**
     * 
     * @type {AsyncStateConfig}
     * @memberof StateFailureRecoveryOptions
     */
    'stateFailureProceedStateConfig'?: AsyncStateConfig;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const StateFailureRecoveryPolicy = {
    FailProcessOnStateFailure: 'FAIL_PROCESS_ON_STATE_FAILURE',
    ProceedToConfiguredState: 'PROCEED_TO_CONFIGURED_STATE'
} as const;

export type StateFailureRecoveryPolicy = typeof StateFailureRecoveryPolicy[keyof typeof StateFailureRecoveryPolicy];


/**
 * 
 * @export
 * @interface StateMovement
 */
export interface StateMovement {
    /**
     * 
     * @type {string}
     * @memberof StateMovement
     */
    'stateId': string;
    /**
     * 
     * @type {EncodedObject}
     * @memberof StateMovement
     */
    'stateInput'?: EncodedObject;
    /**
     * 
     * @type {AsyncStateConfig}
     * @memberof StateMovement
     */
    'stateConfig'?: AsyncStateConfig;
}
/**
 * the definition(key) for getting value of a global attribute table
 * @export
 * @interface TableColumnDef
 */
export interface TableColumnDef {
    /**
     * the column name that can be used in the database query, see below for example
     * @type {string}
     * @memberof TableColumnDef
     */
    'dbColumn': string;
}
/**
 * the value of a global attribute table (from SDK to server or from server to SDK)
 * @export
 * @interface TableColumnValue
 */
export interface TableColumnValue {
    /**
     * the column name that can be used in the database query, see below for example
     * @type {string}
     * @memberof TableColumnValue
     */
    'dbColumn': string;
    /**
     * the plain string value that can be used in the database query(e.g. for SQL SELECT ... WHERE $Column=$dbQueryValue or UPDATE/INSERT)
     * @type {string}
     * @memberof TableColumnValue
     */
    'dbQueryValue': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TableReadLockingPolicy = {
    NoLocking: 'NO_LOCKING',
    ShareLock: 'SHARE_LOCK',
    ExclusiveLock: 'EXCLUSIVE_LOCK'
} as const;

export type TableReadLockingPolicy = typeof TableReadLockingPolicy[keyof typeof TableReadLockingPolicy];


/**
 * 
 * @export
 * @interface TableReadRequest
 */
export interface TableReadRequest {
    /**
     * 
     * @type {string}
     * @memberof TableReadRequest
     */
    'tableName'?: string;
    /**
     * 
     * @type {TableReadLockingPolicy}
     * @memberof TableReadRequest
     */
    'lockingPolicy'?: TableReadLockingPolicy;
    /**
     * 
     * @type {Array<TableColumnDef>}
     * @memberof TableReadRequest
     */
    'columns'?: Array<TableColumnDef>;
}


/**
 * 
 * @export
 * @interface TableReadResponse
 */
export interface TableReadResponse {
    /**
     * 
     * @type {string}
     * @memberof TableReadResponse
     */
    'tableName'?: string;
    /**
     * 
     * @type {Array<TableColumnValue>}
     * @memberof TableReadResponse
     */
    'columns'?: Array<TableColumnValue>;
}
/**
 * 
 * @export
 * @interface ThreadCloseDecision
 */
export interface ThreadCloseDecision {
    /**
     * 
     * @type {ThreadCloseType}
     * @memberof ThreadCloseDecision
     */
    'closeType': ThreadCloseType;
    /**
     * 
     * @type {EncodedObject}
     * @memberof ThreadCloseDecision
     */
    'closeInput'?: EncodedObject;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const ThreadCloseType = {
    ForceCompleteProcess: 'FORCE_COMPLETE_PROCESS',
    GracefulCompleteProcess: 'GRACEFUL_COMPLETE_PROCESS',
    DeadEnd: 'DEAD_END',
    ForceFailProcess: 'FORCE_FAIL_PROCESS'
} as const;

export type ThreadCloseType = typeof ThreadCloseType[keyof typeof ThreadCloseType];


/**
 * 
 * @export
 * @interface TimerCommand
 */
export interface TimerCommand {
    /**
     * 
     * @type {number}
     * @memberof TimerCommand
     */
    'delayInSeconds': number;
}
/**
 * 
 * @export
 * @interface TimerResult
 */
export interface TimerResult {
    /**
     * 
     * @type {CommandStatus}
     * @memberof TimerResult
     */
    'status': CommandStatus;
}


/**
 * 
 * @export
 * @interface WorkerErrorResponse
 */
export interface WorkerErrorResponse {
    /**
     * 
     * @type {string}
     * @memberof WorkerErrorResponse
     */
    'detail'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkerErrorResponse
     */
    'errorType': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary describe a process execution
         * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionDescribePost: async (processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xdb/service/process-execution/describe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionDescribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary send message(s) to be consumed within a single process execution
         * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionPublishToLocalQueuePost: async (publishToLocalQueueRequest?: PublishToLocalQueueRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xdb/service/process-execution/publish-to-local-queue`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(publishToLocalQueueRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary start a process execution
         * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionStartPost: async (processExecutionStartRequest?: ProcessExecutionStartRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xdb/service/process-execution/start`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionStartRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary stop a process execution
         * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionStopPost: async (processExecutionStopRequest?: ProcessExecutionStopRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xdb/service/process-execution/stop`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(processExecutionStopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary invoking AsyncState.execute API
         * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbWorkerAsyncStateExecutePost: async (asyncStateExecuteRequest?: AsyncStateExecuteRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xdb/worker/async-state/execute`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asyncStateExecuteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary invoking AsyncState.waitUntil API
         * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbWorkerAsyncStateWaitUntilPost: async (asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/xdb/worker/async-state/wait-until`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(asyncStateWaitUntilRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for api service to tell async service that there are new immediate tasks added to the queue
         * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XdbNotifyImmediateTasksPost: async (notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/api/v1/xdb/notify-immediate-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyImmediateTasksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary for api service to tell async service that there are new timer tasks added to the queue
         * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XdbNotifyTimerTasksPost: async (notifyTimerTasksRequest?: NotifyTimerTasksRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/internal/api/v1/xdb/notify-timer-tasks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(notifyTimerTasksRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary describe a process execution
         * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XdbServiceProcessExecutionDescribePost(processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessExecutionDescribeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XdbServiceProcessExecutionDescribePost(processExecutionDescribeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary send message(s) to be consumed within a single process execution
         * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XdbServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest?: PublishToLocalQueueRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XdbServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary start a process execution
         * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XdbServiceProcessExecutionStartPost(processExecutionStartRequest?: ProcessExecutionStartRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProcessExecutionStartResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XdbServiceProcessExecutionStartPost(processExecutionStartRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary stop a process execution
         * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XdbServiceProcessExecutionStopPost(processExecutionStopRequest?: ProcessExecutionStopRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XdbServiceProcessExecutionStopPost(processExecutionStopRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary invoking AsyncState.execute API
         * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XdbWorkerAsyncStateExecutePost(asyncStateExecuteRequest?: AsyncStateExecuteRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncStateExecuteResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XdbWorkerAsyncStateExecutePost(asyncStateExecuteRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary invoking AsyncState.waitUntil API
         * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async apiV1XdbWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AsyncStateWaitUntilResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.apiV1XdbWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary for api service to tell async service that there are new immediate tasks added to the queue
         * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internalApiV1XdbNotifyImmediateTasksPost(notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internalApiV1XdbNotifyImmediateTasksPost(notifyImmediateTasksRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary for api service to tell async service that there are new timer tasks added to the queue
         * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async internalApiV1XdbNotifyTimerTasksPost(notifyTimerTasksRequest?: NotifyTimerTasksRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.internalApiV1XdbNotifyTimerTasksPost(notifyTimerTasksRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary describe a process execution
         * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionDescribePost(processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options?: any): AxiosPromise<ProcessExecutionDescribeResponse> {
            return localVarFp.apiV1XdbServiceProcessExecutionDescribePost(processExecutionDescribeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary send message(s) to be consumed within a single process execution
         * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest?: PublishToLocalQueueRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1XdbServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary start a process execution
         * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionStartPost(processExecutionStartRequest?: ProcessExecutionStartRequest, options?: any): AxiosPromise<ProcessExecutionStartResponse> {
            return localVarFp.apiV1XdbServiceProcessExecutionStartPost(processExecutionStartRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary stop a process execution
         * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbServiceProcessExecutionStopPost(processExecutionStopRequest?: ProcessExecutionStopRequest, options?: any): AxiosPromise<void> {
            return localVarFp.apiV1XdbServiceProcessExecutionStopPost(processExecutionStopRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary invoking AsyncState.execute API
         * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbWorkerAsyncStateExecutePost(asyncStateExecuteRequest?: AsyncStateExecuteRequest, options?: any): AxiosPromise<AsyncStateExecuteResponse> {
            return localVarFp.apiV1XdbWorkerAsyncStateExecutePost(asyncStateExecuteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary invoking AsyncState.waitUntil API
         * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1XdbWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options?: any): AxiosPromise<AsyncStateWaitUntilResponse> {
            return localVarFp.apiV1XdbWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for api service to tell async service that there are new immediate tasks added to the queue
         * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XdbNotifyImmediateTasksPost(notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options?: any): AxiosPromise<void> {
            return localVarFp.internalApiV1XdbNotifyImmediateTasksPost(notifyImmediateTasksRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary for api service to tell async service that there are new timer tasks added to the queue
         * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        internalApiV1XdbNotifyTimerTasksPost(notifyTimerTasksRequest?: NotifyTimerTasksRequest, options?: any): AxiosPromise<void> {
            return localVarFp.internalApiV1XdbNotifyTimerTasksPost(notifyTimerTasksRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary describe a process execution
     * @param {ProcessExecutionDescribeRequest} [processExecutionDescribeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XdbServiceProcessExecutionDescribePost(processExecutionDescribeRequest?: ProcessExecutionDescribeRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XdbServiceProcessExecutionDescribePost(processExecutionDescribeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary send message(s) to be consumed within a single process execution
     * @param {PublishToLocalQueueRequest} [publishToLocalQueueRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XdbServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest?: PublishToLocalQueueRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XdbServiceProcessExecutionPublishToLocalQueuePost(publishToLocalQueueRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary start a process execution
     * @param {ProcessExecutionStartRequest} [processExecutionStartRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XdbServiceProcessExecutionStartPost(processExecutionStartRequest?: ProcessExecutionStartRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XdbServiceProcessExecutionStartPost(processExecutionStartRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary stop a process execution
     * @param {ProcessExecutionStopRequest} [processExecutionStopRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XdbServiceProcessExecutionStopPost(processExecutionStopRequest?: ProcessExecutionStopRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XdbServiceProcessExecutionStopPost(processExecutionStopRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary invoking AsyncState.execute API
     * @param {AsyncStateExecuteRequest} [asyncStateExecuteRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XdbWorkerAsyncStateExecutePost(asyncStateExecuteRequest?: AsyncStateExecuteRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XdbWorkerAsyncStateExecutePost(asyncStateExecuteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary invoking AsyncState.waitUntil API
     * @param {AsyncStateWaitUntilRequest} [asyncStateWaitUntilRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1XdbWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest?: AsyncStateWaitUntilRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).apiV1XdbWorkerAsyncStateWaitUntilPost(asyncStateWaitUntilRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for api service to tell async service that there are new immediate tasks added to the queue
     * @param {NotifyImmediateTasksRequest} [notifyImmediateTasksRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public internalApiV1XdbNotifyImmediateTasksPost(notifyImmediateTasksRequest?: NotifyImmediateTasksRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).internalApiV1XdbNotifyImmediateTasksPost(notifyImmediateTasksRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary for api service to tell async service that there are new timer tasks added to the queue
     * @param {NotifyTimerTasksRequest} [notifyTimerTasksRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public internalApiV1XdbNotifyTimerTasksPost(notifyTimerTasksRequest?: NotifyTimerTasksRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).internalApiV1XdbNotifyTimerTasksPost(notifyTimerTasksRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



